<!DOCTYPE html>
<html lang="en">
	<head>
		<title>GridBoardEngine.js</title>
		<link href="https://fonts.googleapis.com/css?family=Fira+Code|Montserrat|Noto+Sans+KR|Roboto|Source+Code+Pro&display=swap" rel="stylesheet">
		<link href="image/GBE.ico" rel="icon">
		<link href="css/index.css" rel="stylesheet">
		<script src="gbe.prototype.js"></script>
		<script src="gbe.test.js"></script>
	</head>
	<body>
		<div class="wrap">
			<header class="top-h">
				<h1>GridBoardEngine.js</h1>
				<nav>
					<ul class="navi">
						<li><a href="#">Home</a></li>
						<li><a href="#">About</a></li>
						<li><a href="#">Download</a></li>
						<li><a href="#">Contact</a></li>
						<li><a href="chess/chess.html">Chess</a></li>
						<li><a href="city/index.html">City Game</a></li>
						<li><a href="maze/index.html">Maze game</a></li>
						<li><a href="#">?</a></li>
						<li><a href="#">?</a></li>
						<li><a href="#">?</a></li>
					</ul>
				</nav>
			</header>
			<article>
				<h2>GridBoardEngine.js Framework Project</h2>
				<section>
					<h3>What is GridBoardEngine.js?</h3>
					<p>Is about GridBoardEngine.js too.</p>
				</section>
				<section>
					<h3>Listen, Read Me</h3>
<!--
/* 
	 * 나는 이렇게 만들고 싶다!
	var b1 = new GBE();
	...
	var b2 = new GBE();
	b2.copyBoard(b1);
	
	 * 아니면 이렇게
	var engine = new GBE();
	engine.newBoard({
		name: 'b1',
		x: 10,
		y: 10
	});
	...
	engine.newBoard({
		name: 'b2',
		x: 10,
		y: 20
	});
	
	b1.setSlashMap(2);
	
	b2.copyBoard(b1);
	
	b1.printGrid();
	
	 * 이런식으로 사용할 수 있도록 개발하고 싶다.
	
	*/
-->
					<p>GridBoardEngine.js is OpenSource Engine for Game to Grid.</p>
					<p>그리드 보드 엔진은 오픈소스로서 그리드로 구성된 게임을 위한 것 입니다.</p>
					<p>그리드나 테이블로 구성된 서비스에 데이터를 저장하고 관리하는 체계적인 것을 지원합니다.</p>
					<p>아래는 이 시스템에 대한 설명과 알아두면 좋은 사항 입니다.</p>
					<ul>
						<li>이 시스템은 좌표가 있습니다. 좌표는 가로축이 X이고, 세로축이 Y값을 가집니다. 즉 (x,y)로 구성됩니다.</li>
						<li>그리고 이 시스템은 시작 좌표기준이 존재하는데, (0,0)이나 (1,1)로 시작합니다. 이 기준이 다르면 데이터의 위치가 일치하지 않습니다. 반드시 시작인덱스를 확인하십시오.</li>
						<li>만약 시작인덱스가 1로 시작하고 데이터가 (3,5)에 저장된다면, 왼쪽에서 3번째, 위에서 5번째에 데이터가 저장되어 있다는 것 입니다.</li>
						<li>반대로 시작인덱스가 0으로 시작한다면, 왼쪽에서 4번째, 위에서 6번째에 데이터가 저장되는 것 입니다.</li>
						<li>데이터에 변동이나 변경사항이 발생하면, 이 시스템은 기록스택이 발동됩니다. 기록스택이란 변동사항 등을 저장하며, 아이템의 변경 취소나 기록을 되돌아 볼 때 사용되기도 합니다.</li>
						<li>이 시스템의 구성사항으로 보드, 그리드, 아이템으로 구성됩니다.</li>
						<li>보드는 저장하는 테이블 자체를 가리킵니다.</li>
						<li>그리드는 칸을 나누는 격자 선 같은 개념을 가리킵니다.</li>
						<li>아이템은 칸 자체를 가리킵니다. 여기서 데이터가 저장됩니다.</li>
						<li>아이템에는 어떠한 데이터의 형태든 저장을 할 수 있습니다.</li>
						<li></li>
						<li></li>
						<li></li>
						<li></li>
						<li></li>
						<li>이 시스템은 오로지 자바스크립트 해석기(JavaScript Interpreter)에 의존하고 있습니다. 만약 이 시스템이 중지나 오류로 인한 사태가 발생하게 되면, 보드의 데이터가 증발하게 될 것입니다. 증발하게 되면, 인터프리터에 저장된 데이터를 다시 불러오거나 복구할 수 없습니다.</li>
						<li>그래서 수시로 중지사태에 대비하여 데이터를 서버에 저장하거나 클라이언트에 저장하는 방법을 강력히 권고합니다. getBoard()를 호출하면 보드의 데이터를 불러내올 수 있습니다.</li>
						<li></li>
						<li></li>
						<li></li>
						<li></li>
						<li></li>
					</ul>
					<p></p>
					<p></p>
					<p></p>
				</section>
				<section>
					<h3>이 GridBoardEngine.js는 무슨 용도로 사용되나요?</h3>
					<p>이 엔진은 오목이나 바둑, 체스, 오델로(리버시), 쇼기, 스도쿠, 테트리스, 체커, 지뢰찾기, 사천성, 커넥트 포, 사천성, 도시게임 등 이와 같이 사각형의 그리드가 있는 어떠한 게임이건 쉽게 적용할 수 있는 장점이 있으며, 이 게임을 위한 각종 시스템을 지원합니다.</p>
				</section>
				<section>
					<h3>Are you want Download?</h3>
					<p>Download <a href="#">here</a>.</p>
				</section>
			</article>
			<article>
				<h2>How to Use GridBoardEngine.js?</h2>
				<section>
					<h3>GridBoard 생성하기</h3>
					<p>GridBoard를 생성하는 방법은 무척이나 쉽습니다.</p>
					<div class="code-cell">
						<code>var gridBoard = new GridBoardEngine(x,y);</code>
					</div>
					<p>이렇게 파라미터 값에 x의 크기와 y의 크기를 넣으면, 생성됨을 알 수 있습니다.</p>
				</section>
				<section>
					<h3>GridBoard에 모든 같은 값을 넣기</h3>
					<p>이는 의외로 간단합니다.</p>
					<div class="code-cell">
						<code>var val = 0;</code>
						<code>gridBoard.setAllVal(val);</code>
					</div>
					<p>파라미터 val 값에 값을 넣으면 모든 보드 값이 하나의 값으로 저장됨을 확인할 수 있습니다.</p>
					<p>이 예제에서 모든 값을 0으로 채워짐을 확인할 수 있습니다.</p>
				</section>
				<section>
					<h3>GridBoard에 초기값을 추가하기</h3>
					<p>초기값이란, 나중에 보드가 확장되면 비어있는 값을 채우는 값입니다.</p>
					<div class="code-cell">
						<code>var val = 0;</code>
						<code>gridBoard.setInit(val);</code>
					</div>
					<p>보드 확장을 통해 발생하는 비어있는 아이템의 값을 자동으로 이 초기값으로 채워지게 됩니다.</p>
				</section>
				<section>
					<h3>GridBoard에 초기값과 모든 같은 값을 동시에 넣기</h3>
					<p>이는 의외로 간단합니다.</p>
					<div class="code-cell">
						<code>var val = 1;</code>
						<code>gridBoard.initAllVal(val);</code>
					</div>
					<p>이 예제를 통해 초기값을 1로 설정하고, 전체 아이템 값을 1로 채워짐을 확인할 수 있습니다.</p>
				</section>
				<section>
					<h3>넣기</h3>
					<p>이는 의외로 간단합니다.</p>
					<div class="code-cell">
						<code>gridBoard.setAllVal(val);</code>
					</div>
					<p>파라미터 val 값에 값을 넣으면 모든 보드 값이 하나의 값으로 저장됨을 확인할 수 있습니다.</p>
				</section>
				<section>
					<h3>GridBoard에 모든 같은 값을 넣기</h3>
					<p>이는 의외로 간단합니다.</p>
					<div class="code-cell">
						<code>gridBoard.setAllVal(val);</code>
					</div>
					<p>파라미터 val 값에 값을 넣으면 모든 보드 값이 하나의 값으로 저장됨을 확인할 수 있습니다.</p>
				</section>
				<section>
					<h3>GridBoard에 모든 같은 값을 넣기</h3>
					<p>이는 의외로 간단합니다.</p>
					<div class="code-cell">
						<code>gridBoard.setAllVal(val);</code>
					</div>
					<p>파라미터 val 값에 값을 넣으면 모든 보드 값이 하나의 값으로 저장됨을 확인할 수 있습니다.</p>
				</section>
				<section>
					<h3>GridBoard에 모든 같은 값을 넣기</h3>
					<p>이는 의외로 간단합니다.</p>
					<div class="code-cell">
						<code>gridBoard.setAllVal(val);</code>
					</div>
					<p>파라미터 val 값에 값을 넣으면 모든 보드 값이 하나의 값으로 저장됨을 확인할 수 있습니다.</p>
				</section>
				<section>
					<h3>GridBoard에 있는 값을 좌표로 조회하기</h3>
					<p>x와 y 값으로 해당 좌표의 값을 조회합니다.</p>
					<div class="code-cell">
						<code>gridBoard.find(x,y);</code>
					</div>
					<p>그러나 다음의 <a href="#">설정</a>에 의해 값이 다르게 나올 수 있습니다.</p>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3>indexOf</h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard.indexOf();</code>
					</div>
				</section>
				<section>
					<h3>findIndex</h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard.findIndex();</code>
					</div>
				</section>
				<section>
					<h3>findAll</h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard.findAll();</code>
					</div>
				</section>
				<section>
					<h3>find</h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard.find();</code>
					</div>
				</section>
				<section>
					<h3>filter</h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard.filter();</code>
						<code>var users_under_30 = filter(function(user) { return user.age &lt; 30 });</code>
						<code>console.log(users_under_30.length);</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3>가로, 세로, 대각선 탐색</h3>
					<p>현재 위치에서 가로, 세로, 대각선으로 주변을 탐색할 수 있다.</p>
					<h4>가로 탐색</h4>
					<p>먼저 가로 탐색방법을 알아보겠다.</p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
					<p>양방향이 아닌 한쪽 탐색도 가능하다.</p>
					
					<h4>세로 탐색</h4>
					<p>먼저 가로 탐색방법을 알아보겠다.</p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
					<p>양방향이 아닌 한쪽 탐색도 가능하다.</p>
					
					<h4>대각선 탐색</h4>
					<p>먼저 가로 탐색방법을 알아보겠다.</p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
					<p>양방향이 아닌 한쪽 탐색도 가능하다.</p>
				</section>
				<section>
					<h3>셀의 인접한 4개의 칸을 탐색</h3>
					<p>(컬러제국 게임용) 처럼 사용할 수 있다.</p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3>셀의 인접한 8개의 칸을 탐색</h3>
					<p>(지뢰찾기용) 처럼 사용할 수 있다.</p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3>위의 탐색을 하면서 같은 값을 찾기</h3>
					<p>이는 간단하다. 위의 함수에 일치라는 단어를 앞에 붙이면 된다. 이렇게 : find() -> validFind()</p>
					
					<h4>가로 탐색</h4>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
					<p></p>
					
					<h4>세로 탐색</h4>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
					<p></p>
					
					<h4>대각선 탐색</h4>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
					<p></p>
					
					<h4>인접한 4칸 탐색</h4>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
					<p></p>
					
					<h4>인접한 8칸 탐색</h4>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
					<p></p>
					
					<h4>인접한 X 탐색</h4>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
					<p></p>
				</section>
				<section>
					<h3>값 이동</h3>
					<p>[Ax,Ay]의 값을 [Bx,By]로 이동한다.</p>
					<div class="code-cell">
						<code>gridBoard.move(Ax,Ay,Bx,By);</code>
					</div>
				</section>
				<section>
					<h3>선형 이동</h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3>이 방향으로 이동</h3>
					<p>체스, 쇼기 등 이 전용으로 사용 가능</p>
					<p>이것은 체스의 말(나이트)처럼 배치할 수 있는 것이다.</p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3>선형 내 값 바꿈</h3>
					<p>오델로(리버시)에서 쓰일 수 있다.</p>
					<p>[Ax,Ay]부터 [Bx,By]까지 가로나 세로, 대각선만으로 연결될 수 있다면, 이 선 내에 값이 바뀐다.</p>
					
					<h4>가로</h4>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
					<p></p>
					
					<h4>세로</h4>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
					<p></p>
					
					<h4>대각선</h4>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
					<p></p>
					
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3>시작하는 인덱스 번호 설정하기</h3>
					<p>여기에 [0,0] 또는 [1,1]로 시작하는 체계가 있는데, 이 체계를 직접 변경할 수 있습니다.</p>
					<p>심지어 GridBoard에 값이 저장되더라도 말이죠!</p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3></h3>
					<p></p>
					<div class="code-cell">
						<code>gridBoard</code>
					</div>
				</section>
				<section>
					<h3>보드의 변경절차와 알고리즘</h3>
					<p>보드의 변경절차는 단순하다.</p>
					<ol type="1">
						<li>변경될 사이즈 값을 받는다.</li>
						<li>기존의 사이즈와 변경될 사이즈 값을 불러온다.</li>
						<li>각각의 x와 y의 값을 boolean으로 계산한다.
						<li>만약 x와 y의 계산된 값이 서로 일치하지 않다면(XOR) A.로 간다.</li>
						<li>x와 y의 계산된 값이 서로 일치하면 B.로 간다.</li>
					</ol>
					<ol type="A">
						<li>
							x와 y의 계산된 값이 (x:확장, y:축소) 또는 (x:축소, y:확장)이면 - 확장 후 축소
							<ol type="i">
								<li>먼저 기존 보드를 </li>
								<li>확장되는 축만큼 E.를 실행하여 확장한 보드를 반환받는다. (x축이 확장되고 y축이 축소된다면, x축만 확장한다)</li>
								<li>그리고 축소되는 축만큼 C.를 실행하여 축소한 보드를 반환받는다. (그리고 y축만큼 축소하는 것이다.)</li>
								<li>리사이즈 완료된 보드를 기존의 보드에 덮어쓰기를 시도한다. 성공하면 true를 반환.</li>
								<li>단 하나도 빠짐없이 모두 성공적으로 실행 완료하면 true를 반환한다.</li>
								<li>단, 하나 이상 실패하면 즉시 메서드 실행과 보드 저장이 취소되고, 에러를 출력하고 false를 반환.</li>
							</ol>
						</li>
						<li>
							x와 y의 계산된 값이 (x=y:확장 또는 x=y:축소)이면
							<ol type="i">
								<li>둘이 확장 또는 축소인지 확인한다.</li>
								<li>확장이면, E.로 간다.</li>
								<li>축소이면, C.로 간다.</li>
							</ol>
						</li>
						<li>
							축소
							<ol type="i">
								<li>기존의 맵을 복사해 생성한다. (만일의 사태에 대비해 복사한다)</li>
								<li>복사된 맵을 축소 강행(?)한다. (아웃사이드 데이터는 자동삭제된다)</li>
								<li>파라미터로 받은 progress 값에 따라 처리한다. (기존의 맵을 불러 아웃사이드 데이터를 처리할 수도 있다)</li>
								<li>처리완료된 복사맵을 반환한다. 또는 progress 값에 따라 기존맵에 덮어씌우기하여 성공하면 true를 반환한다.</li>
							</ol>
						</li>
						<li>
							확장
							<ol type="i">
								<li>확장되는 크기의 맵을 생성한다.</li>
								<li>확장된 맵의 모든 아이템의 값을 초기값으로 채운다.</li>
								<li>확장되면, 기존의 보드 안에 있는 모든 아이템을 확장되는 맵에 복사한다.</li>
								<li>처리완료된 복사맵을 반환한다. 또는 valid 값에 따라 기존 맵에 덮어씌우기하여 성공하면 true를 반환한다.</li>
							</ol>
						</li>
					</ol>
					<p>이처럼 절차가 단순해 보이지만, 실로는 복잡한 시스템을 갖추고 있어야 한다.</p>
				</section>
				<section>
					<h3>아주아주 기본적으로 작동해줄 라이브러리들 - 기록 스택 편</h3>
					<p>스택에 있어서 이 데이터를 표준으로 한다. 아래와 같다.</p>
					<div class="code-cell">
						<code>{x: x, y: y, bd: beforeData, ad:afterData, type: stackElementType}</code>
					</div>
					<p>stackElementType이란 스택의 원소 되는 데이터의 타입을 가리킨다. 0은 무시되는 것으로 삭제 처리된다.</p>
					<p>0: "무효", 1: "기본 일반 데이터", 2: "일반 데이터의 집합",</p>
					<p></p>
					<p>3 이상은 pass가 발동되어 발생한 데이터를 가리킨다. 7번은 보드 전체를 통째로 저장하게 되는 것이다. 이는 비효율적임.</p>
					<p>3: "선형 그리기", 4: "사각형 그리기", 5: "", 6: "",</p>
					<p>7: "보드 전체가 바뀜", 8: "", 9: ""</p>
					<p></p>
					<p>스택에 있어서 copy()를 여러번 사용하는 draw()같은 함수를 사용하면, 그리기 함수가 제대로 실행하기 어렵다.</p>
					<p>이 문제에 대해 해결할 수 있는 방법은 스택 패스를 발동시키는 것이다.</p>
					<p></p>
					<p>스택 패스가 발동되면, 발동되는 동안 값이 변동되어도 스택에 저장하지 않는다는 것이다.</p>
					<p></p>
					<p>스택 패스를 사용하는 조건은: 그리기 함수 등을 사용하기 전이다.</p>
					<p>그리기 함수가 호출되기 시작하면, 제일 먼저 스택 함수를 불러내야 한다.</p>
					<p>불러내면, 그리기 함수에서 'A부터 B까지 어떤 타입으로 그린다'라고 스택에 저장한다.</p>
					<p>그리고 스택 패스가 발동되기 시작한다. 발동되는 동안 복사 함수를 반복해도 기록스택에 저장되지 않는다.</p>
					<p>그리기가 완료되면, 함수를 종료하기 전에 활성화 된 스택 패스를 비활성화 시킨다. 그 다음, 그리기 함수를 종료한다.</p>
					<p>이 과정이 스택 패스를 사용하는 방법이다.</p>
					<p></p>
					<p>기록 스택은 2개로 나뉘어 있으며 undoStack과 redoStack으로 나뉜다. 이는 나중에 undo()와 redo()에서 설명한다.</p>
					<p>기록 스택은 스택이라 불린다. 그리고 스택의 원소를 ~~라고 부른다. 이는 시간 순으로 저장되기 때문이다.</p>
					<p>스택의 원소는 보통 좌표와 이전 데이터, 이후 데이터로 이루어져 있다.</p>
					<p></p>
					<p>그러나 스택 패스가 발동되어 저장된 원소는 보통과 다르다.</p>
					<p>그리기의 경우, A와 B의 좌표, A부터 B까지의 선에서 들어오는 데이터 배열, 바뀐 이후의 배열로 구성된다.</p>
					<p>사각형 그리기의 경우, A와 B의 좌표값, A부터 B까지 2차원 배열(그리기 전/그린 후)을 저장한다.</p>
					<p>그러나 slash 그리기나 한 값으로 초기화하기를 사용한 경우,</p>
					<p>경우에 따라 보드 데이터가 불규칙적(초기값을 가진 아이템의 수가 적음)이면 보드를 통째로 저장한다.</p>
					<p>보드 데이터가 규칙적(초기값을 가진 아이템의 수가 많음)이면 해당 좌표와 데이터를 원소로 한 배열을 저장한다.</p>
					<p></p>
					<p>(구조적으로 설명하는 주석이므로 구조적으로, 순차적으로 설명한다)</p>
					<p></p>
					<p>기록 스택에서 undo를 실행하기 위한 방법: undo()를 실행하면 된다.</p>
					<p>먼저 undoStack에 저장된 좌표 값과 데이터를 읽어와 해당 좌표에 값을 복원한다.</p>
					<p>그리고 undoStack에 읽어온 원소는 redoStack에 저장된다. 이걸로 끝.</p>
					<p></p>
					<p>기록 스택에서 redo를 실행히기 위한 방법: redo()를 실행하면 된다.</p>
					<p>먼저 redoStack을 읽어와 해당 좌표에 해당 데이터를 복원한다.</p>
					<p>그리고 redoStack에 읽어온 원소는 undoStack에 저장된다. 이걸로 끝.</p>
					<p></p>
					<p>기록 스택에 저장하기 위한 방법: save()를 실행하면 된다.</p>
					<p>save()의 파라미터 값을 읽어와 undoStack에 저장(추가:push)된다.</p>
					<p>만약 redoStack에 저장된 값이 있다면, 이 스택을 클리어 한다. 이걸로 끝.</p>
					<p></p>
					<p>기록 스택에서 스택 패스를 발동하기 위한 방법: pass()를 실행하면 된다.</p>
					<p>먼저 pass()의 파라미터 값을 받아 분석 후 저장한다.</p>
					<p>그리고 passActivate()를 실행하여 스택 패스를 활성화시킨다. 그걸로 끝.</p>
					<p></p>
					<p>기록 스택에서 스택 패스를 종료하기 위한 방법: unPass()를 실행하면 된다.</p>
					<p>passDeactivate()를 실행하여 스택을 비활성화시킨다. 그걸로 끝.</p>
					<p></p>
					<p>기록 스택에서 패스 데이터를 읽어내는 방법: undo()나 redo()를 실행할 때, loadPass()를 실행하면 된다.</p>
					<p>기존의 기록스택 원소와 다른 타입이므로 이 헤더값을 따로 읽어 pass인 값은 loadPass()를 실행한다.</p>
					<p>loadPass()로 읽어온 원소의 타입에 따라 선형 그리기, 전체 읽기를 실행할 수 있다.</p>
					<p>전체 읽기이면, 현재 보드를 스택에 저장된 보드로 덮어쓰기하게 된다.</p>
					<p>선형 그리기이면 그린다. 이걸로 끝이 아니다.</p>
					<p>완료하면 pass전용 원소를 redo() 또는 undo()에 저장된다.</p>
					<p></p>
				</section>
				<section>
					<h3>GridBoardEngine.js의 탐색 함수</h3>
					<p>아이템 탐색: 선형탐색, 주변 탐색 등, 경로 탐색은 단지 갈 수 있는 수를 찾기 위함이다.</p>
					<p>탐색은 방법이 다른데, 이는 다음과 같다</p>
					<p>선형 탐색은 공통적으로 A부터 B까지 탐색을 하는 것이다. 다만 반환값은 방법별로 다르다. 체스에서 퀸이나 룩, 비숍임.</p>
					<p>주변 탐색은 A 주위에 둘러싸여있는 아이템을 탐색하는 것이다. 탐색방식마다 다르다. 체스에서 폰이나 킹이다.</p>
					<p>특정 탐색이란 특정 좌표로 탐색을 하는 것이다. 나이트 같은 말이 갈 수 있는 곳을 탐색하는 것이다.</p>
					<p>경로 탐색이란 특정 값 안에서 A에서 B까지 최적 또는 최선의 경로를 탐색하여 중간점 좌표를 순서대로 배열하여 반환한다.</p>
					<p><br>{</p>
					
					<ol type="1">
						<li>사용용도로 체스를 둘 때, 말이나 퀸이 배치할 수 있는 좌표 전체를 반환하는 것이고,(이 방법에서 파라미터는 null이나 특정값을 제외할 경우라면 값을 사용하고, 값들이면 배열을 사용)</li>
						<li>오목 등에 사용되며, A부터 5(특정 값)칸 이내 탐색하여 A와 같은 값인지 반환하는 것이고,</li>
						<li>보드의 바깥이나 특정값에 도달하면, 그 이전 좌표를 반환한다. (슬래시맵 만들기에 쓰인다)</li>
						<li>요 방법은 특정값에 도달하면 그 위치의 좌표를 반환한다.</li>
					</ol>
					
					<p>}<br></p>
					<p><br>{</p>
					
					<p>선형 탐색 - 가로, 세로, 대각선으로 방향에 따라 탐색한다.</p>
					<p>가로, 세로라면 체스의 룩이 갈 수 있는 것이고, 대각선은 비숍, 모든 선형은 퀸이 갈 수 있는 지대를 탐색할 때 쓰인다.</p>
					<p>주변 탐색 - 주변 X나 +, ㅁ처럼 주위를 탐색하는 것이다.</p>
					<p>이 위치에서 주변에 무엇이 있는지, 체스에서 폰이나 킹이 갈 수 있는 지대를 탐색하는 것이다.</p>
					<p>특정 탐색 - 체스의 나이트처럼 특정 좌표(주변이나 선형 내에 들어오지 않는 그런 것)를 탐색하는 것이다.</p>
					<p>가로, 세로, 대각선 안으로 들어오지 않는 지대에 주로 사용된다.</p>
					<p>경로 탐색 - 계획할 도시게임에 도입될 것으로, 보드 내 도로를 1이라 했을 때,</p>
					<p>1이라는 값 위에서 차가 A에서 B까지 갈 수 있는 경로를 탐색하는 것이다. 경로탐색에서 최적 경로와 최선 경로가 있다.</p>
					
					<p>}<br></p>
				</section>
			</article>
			<footer>
				<h5>Made by Eun Chong Ju.</h5>
			</footer>
		</div>
	</body>
</html>